# 并发非阻塞的缓存

## 函数记忆问题
缓存函数的结果，达到多次调用但只需计算一次的效果

并发安全版本
- 给Memo加锁
并行请求，重复抑制

现在调用Get，会先获取保护cache map的互斥锁，再从map中查询一个指向已有entry的指针，
- 如果没有查找到，就分配并插入一个新的entry，释放锁；并调用Get函数，设置entry中的res值，最后关闭通道
- 如果entry存在，则其值可能没有准备好，所以主调goroutine需要等待entry准备好才能读取entry中的result数据，具体的实现方法就是从ready通道读取数据，该操作一直阻塞至ready通道关闭
